<h1>
    Performing HTTP Callouts
</h1>

<p>
    The contents of a web page may need to be scraped and the content sent to one or more downstream
    services. In this example, a callout service scrapes a web page and stores the content in a
    standard Salesforce document SObject.
</p>

<p>
    Salesforce requires that callouts execute before DML in any given execution context. For this
    reason, the Service Bus differentiates between <em>callout enabled</em> and <em>non-callout
    enabled</em> services.
</p>

<p>
    The Service Bus assumes a service is non-callout enabled unless the Apex code that supports the
    service explicitly declares its intention to make callouts.
</p>

<p>
    The example below demonstrates how to write a callout enabled service.
</p>

<h3>
    Activity Specification
</h3>

<p>
    Retrieve web content that will be used by other downstream services, specifically:
</p>

<ol>
    <li>
        Retrieve the content of from the page located at
        <a href="http://www.salesforce.com/">www.salesforce.com</a>
    </li>
    <li>
        Store the page content.</li>
    </li>
    <li>
        Facilitate downstream access to the content.
    </li>
</ol>

<h3>
    Prerequisites
</h3>

<p>
    Enable access to the web page by registering a new remote site.
</p>

<ol>
    <li>
        Click Setup &gt; Security Controls &gt; Remote Site Settings &gt; New Remote Site
    </li>
    <li>
        Enter the following details:
        <br />
        <img src="resources/Developer/RemoteSiteSettings.png" />
    </li>
    <li>
        Click <strong>Save</strong>
    </li>
</ol>

<h2>
    Step 1
</h2>

<p>
    Create an Apex class that supports the minimum required service layout.
</p>

<pre>
global class Callout {

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        //..
    }

    override global String toString() {
        //input message
        //..

        //main code block
        //..

        //output message(s)
        //..
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>001</strong> The class does not take a dependency on the Service Bus. All methods, classes and properties must be described with the <code>global</code> keyword.
    <br /><strong>003 - 018</strong> a valid service has two key elements, namely an <code>Summary</code> Marker Class and a <code>toString()</code> method.
    <br /><strong>003 - 006</strong> the <code>Summary</code> Marker Class exposes important properties about the service thereby facilitating correct integration into the Service Bus. The <code>Description</code> is required in order for the class to be recognised as a valid service.
    <br /><strong>009 - 018</strong> the <code>toString()</code> method contains the Apex logic. The method takes a single event message, and returns a collection of zero, one or more output messages.
</p>

<h2>
    <b>Step 2</b>
</h2>

<p>
    Annotate the service with Callout functionality.
</p>

<pre>
global class Callout implements Database.AllowsCallouts {

    global Boolean AllowsCallouts;

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        //..
    }

    override global String toString() {
        //input message
        //..

        //callouts block
        if (this.AllowsCallouts) {
            //..
        }

        //main code block
        //..

        //output message(s)
        //..
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>001</strong> The intent of this service is to make a callout. Deliberately declare this intent by annotating the class signature with the <code>Database.AllowsCallouts</code> interface.
    <br /><strong>003</strong> Any service annotated with the <code> Database.AllowsCallouts</code> interface must simultaneously declare a global boolean member called <code>AllowsCallouts</code>.
    <br /><strong>014 - 017</strong> All callout logic must be contained within an <code>AllowsCallouts block</code>. Furthermore, no DML should execute within this block. (By explicitly separating the callout logic from  DML execution via the <code>AllowsCallouts block</code>, the Service Bus is able to contractually support the Salesforce requirement that callouts must precede DML.)
</p>

<h2>
    Step 3
</h2>

<p>
    Annotate the service with the full Summary Marker Class.
</p>

<pre>
global class Callout implements Database.AllowsCallouts {

    global Boolean AllowsCallouts;

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        String Tag = 'Example';
        String Name = 'CallOut';
        String Icon = 'connect';
        Integer Limits = 1;
        String HelpUrl = Page.CallOutHelp.getUrl();
    }

    override global String toString() {
        //input message
        //..

        //callouts block
        if (this.AllowsCallouts) {
            //..
        }

        //main code block
        //..

        //output message(s)
        //..
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>006</strong> The <code>Description</code> is a string that describes the functionality of the service. This value is surfaced on the services list view by the discovery service. The <code>Description</code> is the minimum required property on the <code>Summary</code> Marker Class in order for the class to be recognised as a valid service.
    <br /><strong>007</strong> The <code>Tag</code> is a string that that groups the service amongst similar services. It is best practise to create your own category and use that for all your custom services. Failure to include a <code>Tag</code> property will group your service under the default 'Untagged' group.
    <br /><strong>008</strong> The <code>Name</code> is a string that describes the friendly name of the service on the list view of the services. The Service Bus will use the Apex class name of your service as the friendly name if you fail to include ths property in your <code>Summary</code> Marker Class.
    <br /><strong>009</strong> the <code>Icon</code> is a string that identifies the specific icon to display next to the service on the list view of the services. Select an icon from the <a href="http://www.famfamfam.com/lab/icons/silk/previews/index_abc.png>famfamfam">icon collection</a> that most closely represents the functionality of your service. Then note the name of the icon and assign it to the <code>Icon</code> property. The Service Bus will use a 'cog' icon to represent your service if you fail to include this property in your <code>Summary</code> Marker Class.
    <br /><strong>010</strong> the <code>Limits</code> constrains the  number of times a service may be executed in a single context. This property  enables  more  work to be performed than would otherwise be possible within prevailing daily Salesforce execution limits. The default is implicitly and conservatively set to <code>1</code>. A simple service that avoids Salesforce governed operations such as SOQL or callouts is a good candidate for a large <code>Limits</code> setting (100 or greater). If however, the service makes use of a  governed operation, ascertain 50% of that particular Salesforce limit and divide by the number of times the service uses the governed operation. The <code>Limits</code> property should not exceed this calculated value.
    <br /><strong>011</strong> the <code>HelpUrl</code> is a string that defines the help page for the service. The help page is surfaced as a link on the list view of the services. Either a VisualForce page reference or an external web page reference can be assigned to this property. If this property is not defined, the Service Bus will surface a user friendly representation of your service by making use of the attributes contained within the service's <code>Summary</code> Marker Class.
</p>

<h2>
    Step 4
</h2>

<p>
    Formalise the toString() method signature by:
</p>

<ul>
    <li>
        taking an input message of type <code>Map&lt;String,Object&gt;</code> and
    </li>
    <li>
        returning a collection of zero, one or more output messages of type <code>Map&lt;String,Object&gt;</code>.
    </li>
</ul>

<pre>
global class Callout implements Database.AllowsCallouts {

    global Boolean AllowsCallouts;

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        String Tag = 'Example';
        String Name = 'CallOut';
        String Icon = 'connect';
        Integer Limits = 1;
        String HelpUrl = Page.CallOutHelp.getUrl();
    }

    override global String toString() {
        Map&lt;String,Object&gt; inputEvent = (Map&lt;String,Object&gt;)Json.deserializeUntyped(this.Event);
        //callouts block
        if (this.AllowsCallouts) {
            //..
        }

        //main code block
        //..

        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{inputEvent};
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>014</strong> the input message is injected into the <code>toString()</code> method in the form of a key-value collection.
    <br /><strong>025</strong> the <code>toString()</code> method returns an output collection of zero, one or more messages.
</p>

<h2>
    Step 05
</h2>

<p>
    Wire-up the callout logic
</p>

<pre>
global  class Callout implements Database.AllowsCallouts {

    global Boolean AllowsCallouts;

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        String Tag = 'Example';
        String Name = 'CallOut';
        String Icon = 'connect';
        Integer Limits = 1;
        String HelpUrl = Page.CallOutHelp.getUrl();
    }

    global String Body;

    override global String toString() {
        Map&lt;String,Object&gt; inputEvent = (Map&lt;String,Object&gt;)Json.deserializeUntyped(this.Event); //input message
        //callouts block
        if (this.AllowsCallouts) {
            HttpRequest request = new HttpRequest();
            request.setMethod('GET');
            request.setEndpoint('http://bigass.force.com/eda');

            HttpResponse response = new Http().send(request);
            this.Body = response.getBody();

            return null;
        }

        //main code block
        //..

        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{inputEvent};
    }
}
</pre>

<h3>Notes</h3>

<p>
    <strong>018 - 028</strong> Implement the callout logic. The callout block must return <code>null</code>. The callout block must never return the body of the callout response.The mechanism to communicate the callout body to the <code>main block</code> is detailed immediately below.
    <br /><strong>014, 025</strong> All callout responses are communicated from the <code>callout block</code> to the  <code>main block</code>  via a user defined global <code>String</code> member. In this example, the <code>String</code> member is (arbitrarily) named <code>Body</code> and is assigned the content of the callout response. In this way, the content of <code>Body</code> is now accessible to methods and variables inside the <code>main block</code>.
</p>

<h2>
    Step 6
</h2>

<p>
    Complete the implementation of the business logic.
</p>

<pre>
global  class Callout implements Database.AllowsCallouts {

    global Boolean AllowsCallouts;

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        String Tag = 'Example';
        String Name = 'CallOut';
        String Icon = 'connect';
        Integer Limits = 1;
        String HelpUrl = Page.CallOutHelp.getUrl();

        Map&lt;String,String&gt; Outputs = new Map&lt;String,String&gt;{
            'RecordId' =&gt;'ID modified to reference a document containing the contents of the scraped input url (c:Url))'
        };
    }

    global String Body;

    override global String toString() {
        Map&lt;String,Object&gt; inputEvent = (Map&lt;String,Object&gt;)Json.deserializeUntyped(this.Event); //inputs
        if (this.AllowsCallouts) {
            HttpRequest request = new HttpRequest();
            request.setMethod('GET');
            request.setEndpoint('http://bigass.force.com/eda');

            HttpResponse response = new Http().send(request);
            this.Body = response.getBody();

            return null;
        }


        //main code block
        Document document = new Document(
            Name = 'Mydoc' + system.now() + '.html',
            FolderId = UserInfo.getUserId(),
            Body = Blob.valueOf(this.Body)
        );
        insert document;
        inputEvent.put('RecordId', document.Id);


        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{inputEvent};
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>034 - 041</strong> The <code>main block</code> completes the implementation of the business specification by the persisting the callout content in a standard <code>Document</code> SObject.
    <br /><strong>018, 038</strong> The content of the callout response is retrieved from the global  member <code>Body</code> and assigned to the body of the <code>document</code> SObject.
    <br /><strong>041</strong> <code>RecordId</code> is a standard parameter of any message and it normally points to the underlying data (SObject) of the message. Any service is free to update this <code>RecordId</code> parameter to conform with the requirements of the service business specification. In this example, the response content is persisted as a Salesforce <code>Document</code> and for that reason the <code>RecordId</code> parameter of the outbound message is updated with the <code>Id</code> of the inserted document.
    <br /><strong>041, 013 - 015</strong> If a service modifies or adds a parameter on any outbound message, the modification should be formally described by detailing the parameter name and a comment describing the modification.
</p>

<p>
    Below is an annotated callout service called <code>Callout</code>. This service adheres to the
    required Service Bus callout template.
</p>

<h3>
    Specification
</h3>

<p>
    The service inspects the parameters of the input event and retrieves the url of a specific
    web page to be scraped. The content of the scraped page is stored as a Salesforce document. Most
    importantly, the <code>RecordId</code> parameter of the outbound message is updated with the Id
    of this Salesforce document so that any downstream services will have access to that scraped
    data.
</p>

<pre>
global class Callout implements Database.AllowsCallouts {

    global Boolean AllowsCallouts;

    global class Summary {
        String Description = 'Does an HTTP CallOut and saves it as a Document.';
        String Tag = 'Example';
        String Name = 'CallOut';
        String Icon = 'connect';
        Integer Limits = 1;
        String HelpUrl = Page.CallOutHelp.getUrl();

        Map&lt;String,String&gt; Inputs = new Map&lt;String,String&gt;{
            'c:Url' => 'STRING representing Url to scrape.'
        };
        Map&lt;String,String&gt; Outputs = new Map&lt;String,String&gt;{
            'RecordId' =>'ID of a document containing the contents of the scraped input URL.'
        };
    }

    global String Body;

    override global String toString() {
        Map&lt;String,Object&gt; inputEvent = (Map&lt;String,Object&gt;)Json.deserializeUntyped(this.Event);
        if (this.AllowsCallouts) {
            String url = (String)inputEvent.get('c:Url');
            HttpRequest request = new HttpRequest();
            request.setMethod('GET');
            request.setEndpoint(url);

            HttpResponse response = new Http().send(request);
            this.Body = response.getBody();

            return null;
        }


        //main code block
        Document document = new Document(
            Name = 'Mydoc'+system.now()+'.html',
            FolderId = UserInfo.getUserId(),
            Body = Blob.valueOf(this.Body)
        );
        insert document;
        inputEvent.put('RecordId', document.Id);


        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{inputEvent};
    }
}
</pre>


<h3>
    Notes
</h3>

<p>
    <strong>001</strong> an service is a standard Apex class. Services do not take any dependency on the Service Bus.
    <br /><strong>001 - 051</strong> a valid service has two key elements, namely a <code>Summary</code> Marker Class and a <code>toString()</code>method.
    <br /><strong>005 - 019</strong> the <code>Summary</code> Marker Class exposes important properties about the service thereby facilitating correct integration into the Service Bus.
    <br /><strong>006</strong> the <code>Description</code> is a string that describes the functionality of the service and is surfaced on the list view of the services by the discovery service.
    <br /><strong>007</strong> the <code>Tag</code> is a string that that groups the service with similar services. We recommend that you create your own categories for custom services.
    <br /><strong>008</strong> the <code>Name</code> is a string that describes the friendly <code>Name</code> of the service.
    <br /><strong>009</strong> the <code>Icon</code> is a unique string that defines the icon that will appear next to the service when viewed on the list view of services.
</p>

<fieldset>
    <legend>Note</legend>
    The full collection of  possible icons can be found <a href=http://www.famfamfam.com/lab/icons/silk/previews/index_abc.png>here</a>.
</fieldset>

<p>
    <strong>010</strong> <code>Limits</code> constrains the number of times a service may be executed in a single context.
</p>

<fieldset>
    <legend>Note</legend>
    <p>
        This property enables more work to be performed than would otherwise be possible within
        prevailing daily Salesforce execution limits.
    </p>
    <ul>
        <li>The default is implicitly and conservatively set to one.</li>
        <li>
            A simple service that avoids Salesforce governed operations such as SOQL or callouts is
            a good candidate for a large <code>Limits</code> setting. (100 or greater)
        </li>
        <li>
            If however, the service makes use of a governed operation, ascertain 50% of that
            particular Salesforce limit and divide by the number of times the service uses the
            governed operation. The <code>Limits</code> property must not exceed this calculated
            value.
        </li>
    </ul>
</fieldset>

<p>
    <strong>011</strong> the <code>HelpUrl</code> is a string that describes the help page for the
    service.
</p>

<fieldset>
    <legend>Note</legend>
    The help page does not have to be in the form of a VisualForce page. External help page
    references are also valid.
</fieldset>

<p>
    <strong>013 - 015</strong> the <code>Inputs</code> property documents all expected inputs.
</p>

<fieldset>
    <legend>Note</legend>
    This documentation supports auto generated help for the service.
</fieldset>

<p>
    <strong>016 - 018</strong> the <code>Outputs</code>  property documents all outputs added,
    deleted or modified
</p>

<fieldset>
    <legend>Note</legend>
    This documentation supports auto generated help for the service.
</fieldset>

<p>
    <strong>023 - 050</strong> the <code>toString()</code> method contains the Apex logic. The method takes a single event message and returns zero, one or more output messages as a collection.
    <br /><strong>001 - 051</strong> services making callouts must be annotated in a manner that declares the service's intent to make one or more callouts.
    <br /><strong>001</strong> the class must implement the the <code>Database.AllowsCallouts</code> interface.
    <br /><strong>003</strong> the class must expose a global Boolean member called <code>AllowsCallouts</code>
    <br /><strong>025 - 035</strong> all <em>callout logic</em> must be implemented within a callout code block. The <em>callout logic</em>  must return null, not the body of the callout response.
    <br /><strong>021, 042</strong> the <em>main block</em> accesses callout content through class instance properties. Every callout should have a corresponding String class property. It is left to the developer of the service to appropriately name the properties.
</p>