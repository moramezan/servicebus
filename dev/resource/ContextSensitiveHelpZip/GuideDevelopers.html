<h1>
    Service Developers Guide
</h1>

<p>
    Intended audience: Salesforce Apex Developer.
</p>

<h2>
    About This Guide
</h2>

<p>
    This guide is intended for Salesforce Apex Developers who are tasked with providing
    functionality not provided in the out-of-the-box Service Bus. The purpose of this guide is to:
</p>

<ol>
    <li>
        explain basic service concepts as they pertain to the Service Bus.
    </li>
    <li>
        describe how to create a service that enables processing functionality not directly provided
        for in the Service Bus.
    </li>
</ol>

<p>
    This guide excludes Service Bus configuration and monitoring. These topics are covered in the
    separate <a href="?topic=GuideOrchestrators">Orchestrators Guide</a>.
</p>

<h2>
    Getting Started
</h2>

<p>
    All services contain a standard <code>toString()</code> method. The <code>toString()</code>
    method takes a single input message and returns a list containing zero, one or many message(s).
    The concept can be illustrated as follows:
</p>

<!--
 ! TODO confuser?
 !-->

<pre>
List&lt;Event&gt; messages = service.handle(Event message);
</pre>

<p>
    The Service Bus is designed so that the output(s) from a given service can be directly
    re-purposed as input(s) into immediately downstream services.
</p>

<p>
    The Service Bus has by default a number of pre-packaged native services that can be
    sequenced together to accomplish useful work.
</p>

<p>
    These pre-packaged services include <em>Branch</em>, <em>Gate</em>, <em>Jump</em>,
    <em>LogInitializer</em>, <em>LogWriter</em>, <em>Mark</em>, <em>Publish</em>, <em>Schedule</em>,
    <em>Subscribe</em>, <em>Subsequence</em>, <em>Terminate</em> and <em>WireTap</em>.
</li>

<p>
    Additional services are easily created to implement tasks specific to a particular business
    requirement.
</p>

<p>
    The focus of this guide is to provide detailed guidance for the creation of these services.
</p>

<h2>
    Overview of development lifecycle
</h2>

<p>
    The list below describes the order of activities for creating, testing and deploying your service:
</p>

<ol>
    <li>
        Define the input event
    </li>
    <li>
        Define the output event(s) (if any)
    </li>
    <li>
        <p>
            Define the service activity in the form of a service specification.
        </p>
        <fieldset>
            <legend>Note</legend>
            This step would normally be performed by the System Architect, System Orchestrator or a
            Business Analyst.
        </fieldset>
    </li>
    <li>
        <p>
            Convert the specification into a service with accompanying unit tests -
            see <a href="?topic=GuideBuildingTesting">building and testing the service</a>
        </p>
        <fieldset>
            <legend>Note</legend>
            A Force.com developer would normally perform this step
        </fieldset>
    </li>
    <li>
        Visually test the service - see <a href="#CHAPTER06">post-build steps</a>
    </li>
    <li>
        Create a package containing your service and install in the runtime enviroment
        (Sandbox, Production, etc). - see <a href="#CHAPTER06">post-build steps</a>
    </li>
</ol>

<h2>
    Define the Service
</h2>

<p>
    Define the input event:
</p>

<ul>
    <li>
        Every input event message is a loosely typed key-value map of the form
        <code>Map&lt;String,Object&gt;</code>
    </li>
    <li>
        Of particular importance is the <code>RecordId</code> parameter.
    </li>
    <li>
        The <code>RecordId</code> parameter points at the underlying data associated with the message.
    </li>
    <li>
        The service author should be familiar with the structure of the data (SObject) pointed at by
        the event so that he/she can adequately retrieve and write to this object.
    </li>
</ul>

<p>
    Define the output event(s):
</p>

<ul>
    <li>
        An output event message is takes the same shape as an input event message - that is, a
        loosely typed key-value map of the form <code>Map&lt;String,Object&gt;</code>
    </li>
    <li>
        <p>
            A service returns an output collection containing zero, one or more messages in the form
            <code>List&lt;Map&lt;String,Object&gt;&gt;</code>
        </p>
        <fieldset>
            <legend>Note</legend>
            Normally the output collection will simply contain a single output message, namely the
            re-purposed input message.
        </fieldset>
    </li>
</ul>

<h2>
    Defining the service activity
</h2>

<ul>
    <li>
        The service activity represents specific logic that is unavailable under the Service Bus,
        either because such logic is is not represented by one of the native framework services, or
        such logic has not been previously created and/or registered.
    </li>
    <li>
        The service activity should be <em>specific</em>. An example of specific activity might be
        converting Unix line terminators to Windows line terminators. An example of
        <em>un-specific</em> activity might be the counting of word occurrences in a file,
        alphabetising the summary counts by word and finally reporting the results.
    </li>
    <li>
        Generally defined activities should be re-specified into separate specific activites. Using
        the example above, one could envisage three separate activities, namely: count, sort and
        report. The more focused an activity, the easier it becomes to write comprehensive, reliable
        unit tests. And the easier it becomes to re-purpose the service in other sequences cutting
        down on programmer effort and the potential for bugs (less code).
    </li>
</ul>

<p>
    The Service Bus surfaces the notion of attributes via <strong>Step Config</strong>
    and <strong>Service Settings</strong> to accommodate variations in data applied to the same
    service behavior
</p>

<ul>
    <li>
        <strong>Step Config</strong> allows a service to make use of attributes having values
        configured that are specific to the context of each <em>step</em> the service belongs to.
    </li>
    <li>
        <strong>Service Settings</strong> allow a service to make use of a single set of parameters
        without reference to the context of the sequence step containing the service. These
        parameters are defined in a Custom Setting specific to that service class.
    </li>
</ul>
