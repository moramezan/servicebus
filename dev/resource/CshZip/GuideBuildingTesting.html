<h1>
    Building and testing a process
</h1>

<p>
    Before creating your first process plugin, it is assumed that the ESB framework has been
    installed in your org.
</p>

<fieldset>
    <legend>Note</legend>
    This requirement merely facilitates the visual testing of newly created ESB processes and
    nothing more. A fundamental principle of the Event Driven Architecture is a dependency reduced
    environment. For this reason, custom processes never take a dependency on the ESB framework.
</fieldset>

<p>
    <strong>
        The first step is to create a new global class in a development org. Confirm that the class
        follows the expected ESB process plugin template as set out below. You can also build
        appropriate unit tests as required by Salesforce.
    </strong>
</p>

<h2>
    Anatomy of a Process
</h2>

<p>
    Before a custom plugin can be recognised and registered in the ESB framework, the code
    representing the plugin must conform to an ESB template that at a minimum, consists of:
</p>

<ul>
    <li>an inner <code>ESB</code> Marker Class, and</li>
    <li>an <code>invoke()</code> method.</li>
</ul>

<p>
    Below is an annotated non-callout plugin called <em>ChatterTap</em>. This plugin adheres to the
    required ESB template.
</p>

<h3>
    Specification
</h3>

<p>
    The ESB framework has a built-in <em>WireTap</em> process that surfaces the parameters of an
    inbound message via an email. The email is sent to either:
</p>

<ul>
    <li>
        the inbox of the running context user (default behaviour), or
    </li>
    <li>
        the inbox of a nominated user as defined by a custom setting associated with the
        <em>WireTap</em> process
    </li>
</ul>

<p>
    This plugin will replicate the <em>WireTap</em> functionality. But as an alternative to
    surfacing the message parameters in the form of an email, <em>ChatterTap</em> will instead post
    these parameters on a user's Chatter Feed.
</p>

<pre>
global class ChatterTap {

    global class Meta {
        global String Tag = 'Example';
        global String Name = 'ChatterTap';
        global String Description = 'Inserts the message parameters on user chatterfeed.';
        global String Icon = 'comment';
        global Integer Limits = 1;
        global String HelpUrl = Page.ChatterTapHelp.getUrl();
        global SObject CustomSetting = ChatterTapSettings__c.SObjectType.newSObject();
    }


    global List&lt;Map&lt;String,Object&gt;&gt; invoke(Map&lt;String,Object&gt; parameters) {  //input message

        //main code block
        Id userId;
        ChatterTapSettings__c setting = ChatterTapSettings__c.getInstance();
        if (setting.UserId__c == null) {
            userId = UserInfo.getUserId();
        } else {
            userId = setting.UserId__c;
        }

        FeedItem post = new FeedItem(
            ParentId = userId,
            Body = '[ChatterTap] '
            + parameters.get('eda_SequenceName')
            + '#'
            + parameters.get('eda_Position')
        );
        insert post;

        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{parameters};
    }
}
</pre>

<p>
    Notes:
</p>

<p>
    <strong>001</strong> an ESB plugin is a standard Apex class. ESB plugins do not take any dependency on the ESB package.
    <br /><strong>003 - 036</strong> a valid ESB plugin has two key elements, namely an inner <code>ESB</code> class and an <code>invoke()</code> method.
    <br /><strong>003 - 011</strong> the inner <code>ESB</code> class exposes important properties about the ESB plugin thereby facilitating correct integration into the ESB framework.
    <br /><strong>004</strong> the <code>Tag</code> is a string that that groups the ESB plugin with similar plugins. We recommend that you create your own categories for custom plugins.
    <br /><strong>005</strong> the <code>Name</code> is a string that describes the friendly <code>Name</code> of the ESB plugin
    <br /><strong>006</strong> the <code>Description</code> is a string that describes the functionality of the plugin and is surfaced on the list view of all ESB processes by the discovery process.
    <br /><strong>007</strong> the <code>Icon</code> is a unique string that defines the icon that will appear next to the plugin when viewed  on the list view of ESB processes.
</p>

<fieldset>
    <legend>Note</legend>
    The full collection of  possible icons can be found <a href=http://www.famfamfam.com/lab/icons/silk/previews/index_abc.png>here</a>.
</fieldset>

<p>
    <strong>008</strong> <code>Limits</code> constrains the number of times a plugin may be executed in a single context.
</p>

<fieldset>
    <legend>Note</legend>
    <p>
        This property enables more work to be performed than would otherwise be possible within
        prevailing daily Salesforce execution limits.
    </p>
    <ul>
        <li>The default is implicitly and conservatively set to one.</li>
        <li>
            A simple plugin that avoids Salesforce governed operations such as SOQL or callouts is
            a good candidate for a large <code>Limits</code> setting. (100 or greater)
        </li>
        <li>
            If however, the plugin makes use of a governed operation, ascertain 50% of that
            particular Salesforce limit and divide by the number of times the plugin uses the
            governed operation. The <code>Limits</code> property must not exceed this calculated
            value.
        </li>
    </ul>
</fieldset>

<p>
    <strong>009</strong> the <code>HelpUrl</code> is a string that describes the help page for the
    plugin.
</p>

<fieldset>
    <legend>Note</legend>
    The help page does not have to be in the form of a VisualForce page. External help page
    references are also valid.
</fieldset>

<p>
    <strong>010</strong> Surfacing a link to the plugin specific custom settings on the processes list view is possible. Simply assign an instance of the custom setting to the <code>CustomSetting</code> member of the plugin's <code>ESB</code> marker class.
    <br /><strong>014 - 036</strong> the <code>invoke()</code> method contains the Apex logic that implements the business specification.
    <br /><strong>014</strong> an input message is injected into the <code>invoke()</code> method in the form of key-value  collection.
    <br /><strong>035</strong> the <code>invoke()</code> method returns a list of zero, one or more output messages. Each output message consists of a key-value parameter collection.
</p>

<!--
 ! TODO something split up here
 !-->

<h2>
    Example process
</h2>

<p>
    The <em>WireTap</em> process is a built-in NOOP framework process that sends an email to an
    interested user whenever it receives an event message. The email contains details about the
    sequence step hosting the <em>WireTap</em> process as well as the injected message parameters
</a>

<p>
    As an alternative to the the <em>WireTap</em> process, we will construct a new process called
    <em>ChatterTap</em>. Instead of emailing an interested user, the same detail will instead be
    surfaced on that user's chatter feed.
</p>

<h2>
    Activity Specification
</h2>

<p>
    The  activity specification is very similar to that of the <em>WireTap</em>.
</p>

<ol>
    <li>
        The activity has no side effects on processing, therefore return the untouched inbound event
        message as the only item in the returned output message collection.
    </li>
    <li>
        The chatter feed that will surface details about the inbound event will be the chatter feed
        of a a specific user as defined by the <code>UserId</code> field of the <em>ChatterTap</em>
        custom setting.
    </li>
    <li>
        If no <code>UserId</code> has been entered in the <code>ChatterTap</code> custom setting,
        use the <code>Id</code> of the running user context
    </li>
</ol>

<h2>
    Prerequisites
</h2>

<p>
    Create the custom setting to hold the <em>ChatterTap</em> customization by clicking Setup &gt;
    Develop &gt; Custom Setting &gt; New
    <br />
    <img src="resources/Developer/CustomSettingDefinition.png" /><br />
    <br />
    <img src="resources/Developer/ChatterTapSettings.png" />
</p>

<p>
    Add a custom setting field to hold the <code>UserId</code> of the chatter feed.
    <br />
    <img src="resources/Developer/ChatterSettingsUserId.png" />
</p>

<p>
    Create a new VisualForce page called <code>ChatterTapHelp</code>. This page represents the help
    documentation supporting the <code>ChatterTap</code> process plugin.
</p>

<p>
    Confirm that chatter is enabled for your org. If necessary, click Setup &gt; Chatter &t;
    Settings and check <strong>Enable</strong>.
    <br />
    <img src="resources/Developer/ChatterSettings.png" />
</p>

<h2>
    Step 1
</h2>

<p>
    Create an Apex class that supports the  minimum required plugin layout.
</p>

<pre>
global  class ChatterTap {

    global class Meta {
        public String Description = 'Inserts the message parameters on user chatterfeed.';
        //..
    }


    global void invoke() {
        //input message
        //..

        //main code block
        //..

        //output message(s)
        //..
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>001</strong> The class does not take a dependency on the ESB framework. All methods, classes and properties must be described with the <code>global</code> keyword.
    <br /><strong>003 - 018</strong> a valid ESB plugin has two key elements, namely an inner <code>ESB</code> class and an <code>invoke()</code> method.
    <br /><strong>003 - 006</strong> the inner <code>ESB</code> class exposes important properties about the ESB plugin thereby facilitating correct integration into the ESB framework. The <code>Description</code> is required in order for the class to be recognised as a valid ESB process.
    <br /><strong>009 - 018</strong> the <code>invoke()</code> method contains the Apex logic. The method takes a single event message, and returns  a collection of zero, one or more output messages.
</p>

<h2>
    Step 2
</h2>

<p>
    Annotate the process.
</p>

<pre>
global  class ChatterTap {

    global class Meta {
        global String Description = 'Inserts the message parameters on user chatterfeed.';
        global String Tag = 'Example';
        global String Name = 'ChatterTap';
        global String Icon = 'comment';
        global Integer Limits = 1;
        global String HelpUrl = Page.ChatterTapHelp.getUrl();
    }


    global void invoke() {
        //input message
        //..

        //main code block
        //..

        //output message(s)
        //..
    }
}
</pre>

<h3>
    Notes
</h3>


<p>
    <strong>004</strong> The <code>Description</code> is a string that describes the functionality of the plugin. This value is surfaced on the processes list view by the ESB discovery process. The <code>Description</code> is required in order for the class to be recognised as a valid ESB process.
    <br /><strong>005</strong> The <code>Tag</code> is a string that that groups the ESB process amongst similar others. It is best practise to use categories. Failure to include a <code>Tag</code> property will group your plugin under the default 'Untagged' group.
    <br /><strong>006</strong> The <code>Name</code> is a string that describes the friendly name of the ESB plugin on the list view of the ESB processes. The ESB framework will use the Apex class name of your plugin as the friendly name if you fail to include ths property in your <code>ESB</code> marker class.
    <br /><strong>007</strong> the <code>Icon</code> is a string that identifies the specific icon to display next to the plugin on the list view of the ESB processes. Select an icon from the <a href=http://www.famfamfam.com/lab/icons/silk/previews/index_abc.png>famfamfam</a> icon collection that most closely represents the functionality of your plugin. Then note the name of the icon and assign it to the <code>Icon</code> property. The ESB framework will use a 'cog' icon to represent your plugin if you fail to include ths property in your <code>ESB</code> marker class.
    <br /><strong>008</strong> the <code>Limits</code> constrains the number of times a plugin may be executed in a single context. This property  enables more work to be performed than would otherwise be possible within prevailing daily Salesforce execution limits. The default is implicitly and conservatively set to one. A simple plugin that avoids Salesforce governed operations such as SOQL or callouts is a good candidate for a large <code>Limits</code> setting (100 or greater). If however, the process makes use of a governed operation, ascertain 50% of that particular Salesforce limit and divide by the number of times the plugin uses the governed operation. The <code>Limits</code> property should not exceed this calculated value.
    <br /><strong>009</strong> the <code>HelpUrl</code> is a string that defines the help page for the plugin. The help page is surfaced as a link  on the list view of the ESB processes. Either a VisualForce page reference or an external web page reference can be assigned to this property. If this property is not defined, the ESB framework will surface a user friendly representation of your plugin by making use of the attributes contained within the plugin's <code>ESB</code> marker class.
</p>

<h2>
    Step 3
</h2>

<p>
    Formalise the invoke() method signature by:
</p>

<ul>
    <li>
        taking an input message of type <code>Map&lt;String,Object&gt;</code> and
    </li>
    <li>
        returning a collection of zero, one or more output messages of type <code>Map&lt;String,Object&gt;</code>.
    </li>
</ul>

<pre>
global class ChatterTap {

    global class Meta {
        global String Description = 'Inserts the message parameters on user chatterfeed.';
        global String Tag = 'Example';
        global String Name = 'ChatterTap';
        global String Icon = 'comment';
        global Integer Limits = 1;
        global String HelpUrl = Page.ChatterTapHelp.getUrl();
    }


    global List&lt;Map&lt;String,Object&gt;&gt; invoke(Map&lt;String,Object&gt; parameters) {  //input message

        //main code block
        //..

        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{parameters};
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>013</strong> the input message is injected into the <code>invoke()</code> method in the form of a key-value collection.
    <br /><strong>020</strong> the <code>invoke()</code> method returns an output collection of zero, one or more messages.
</p>

<h2>
    Step 4
</h2>

<p>
    Wire-up plugin Custom Settings and initiate the business logic implementation.
</p>

<pre>
global class ChatterTap {

    global class Meta {
        global String Description = 'Inserts the message parameters on user chatterfeed.';
        global String Tag = 'Example';
        global String Name = 'ChatterTap';
        global String Icon = 'comment';
        global Integer Limits = 1;
        global String HelpUrl = Page.ChatterTapHelp.getUrl();
        global SObject CustomSetting = ChatterTapSettings__c.SObjectType.newSObject();
    }


    global List&lt;Map&lt;String,Object&gt;&gt; invoke(Map&lt;String,Object&gt; parameters) {  //input message

        //main code block
        Id userId;
        ChatterTapSettings__c setting = ChatterTapSettings__c.getInstance();
        if (setting.UserId__c == null) {
            userId = UserInfo.getUserId();
        } else {
            userId = setting.UserId__c;
        }

        //..

        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{parameters};
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>016 - 023</strong> Under the main code block, initiate the business logic implementation. The specification defines the preferred chatter feed owner as being the User Id defined the custom settings of the plugin. For this reason, the code references <code>ChatterTapSettings__c</code> to determine if the default chatter (User) Id should been overwritten.
    <br /><strong>010</strong> To surface a link to the custom settings page of your plugin directly on the ESB processes list view: assign an instance of your custom setting SObject to the CustomSetting parameter of the plugin's <code>Meta</code> inner class.
</p>

<h2>
    Step 5
</h2>

<p>
    Complete the business logic implementation
</p>

<pre>
global class ChatterTap {

    global class Meta {
        global String Description = 'Inserts the message parameters on user chatterfeed.';
        global String Tag = 'Example';
        global String Name = 'ChatterTap';
        global String Icon = 'comment';
        global Integer Limits = 1;
        global String HelpUrl = Page.ChatterTapHelp.getUrl();
        global SObject CustomSetting = ChatterTapSettings__c.SObjectType.newSObject();
    }


    global List&lt;Map&lt;String,Object&gt;&gt; invoke(Map&lt;String,Object&gt; parameters) {  //input message

        //main code block
        Id userId;
        ChatterTapSettings__c setting = ChatterTapSettings__c.getInstance();
        if (setting.UserId__c == null) {
            userId = UserInfo.getUserId();
        } else {
            userId = setting.UserId__c;
        }

        FeedItem post = new FeedItem(
            ParentId = userId,
            Body = '[ChatterTap] '
            + parameters.get('eda_SequenceName')
            + '#'
            + parameters.get('eda_Position')
        );
        insert post;

        //output message(s)
        return new List&lt;Map&lt;String,Object&gt;&gt;{parameters};
    }
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>025 - 032</strong> Complete the implementation of the business specification. In this example, the parameters surfaced to a given chatter feed are deliberately limited to the Sequence Name (<code>esb__SequenceName</code>) and Sequence Position (<code>esb__Position</code>).
</p>

<h2>
    Step 6
</h2>

<p>
    Test the plugin. Tests will normally cover:
</p>

<ul>
    <li>the expected <code>ESB</code> (for example, the <code>Description</code>)</li>
    <li>the expected initial state (for example, the Custom settings supporting the plugin)</li>
    <li>that expected exceptions are thrown for invalid 1initial state</li>
    <li>the expected outputs (for example, the count of the messages in the output collecton)</li>
    <li>the expected side effects (for example, the insertion of certain records such as a <code>FeedItem</code>)</li>
</ul>

<p>
    Most plugins will exhibit a set of tests similar to those shown below.
</p>

<pre>
@IsTest   
private class ChatterTapTest {  
      
    static testmethod void processIsDescribed() {  
        ChatterTap.Meta meta = new ChatterTap.Meta();  
        System.assertNotEquals(null, meta.Description);  
    }  
 
 
 
    static testmethod void callingInvokeDoesNOTThrowErrorWhenCustomSettingSet() {
        //arrange 
        insert new ChatterTapSettings__c ();  // default
        
        ChatterTap plugin = new ChatterTap();
        Map&lt;String,Object&gt; parameters = new Map&lt;String,Object&gt;();
 
        //act
        List&lt;Map&lt;String,Object&gt;&gt; outputs = plugin.invoke(parameters); 
            
        //assert
        System.assert(true, 'ChatterTap ran OK.');
    }
 
 
    static testmethod void callingInvokeExecutesCorrectly01() {  
        // Arrange   
        insert new ChatterTapSettings__c ();  // default
  
        Map&lt;String,Object&gt; parameters = new Map&lt;String,Object&gt; {
            'ns_YourKey' =&gt; 'your data'  
        };  
 
        // Act  
        ChatterTap plugin = new ChatterTap();  
        List&lt;Map&lt;String,Object&gt;&gt; results = plugin.invoke(parameters);  
  
        // Assemble  
        Integer actualSize = results.size();  
        
        // Assert  
        Integer expectedSize = 1;  
        System.assertEquals(expectedSize, actualSize);  
    }
 
    static testmethod void callingInvokeExecutesCorrectly02() {  
        // Arrange   
        insert new ChatterTapSettings__c ();  // default 
  
        Map&lt;String,Object&gt; parameters = new Map&lt;String,Object&gt; {
            'ns_YourKey' =&gt; 'your data'  
        };  
          
        Integer actualFeedItemsBeforeSize = [SELECT Id, Body FROM FeedItem].Size();  
  
        // Act  
        ChatterTap plugin = new ChatterTap();  
        List&lt;Map&lt;String,Object&gt;&gt; results = plugin.invoke(parameters);  
  
        // Assemble  
        Integer actualFeedItemsAfterSize = [SELECT Id, Body FROM FeedItem].Size();  
        Integer actualSize = actualFeedItemsAfterSize - actualFeedItemsBeforeSize;   
  
        // Assert  
        Integer expectedSize = 1;  
        System.assertEquals(expectedSize, actualSize);  
    }    
}
</pre>

<h3>
    Notes
</h3>

<p>
    <strong>004 - 007</strong> Test the plugin correctly implements the inner <code>ESB</code> marker class.
    <br /><strong>011 - 023</strong> The plugin relies on a custom setting instance and should not throw an error if this custom setting exists
    <br /><strong>026 - 044</strong> The plugin should return exactly one message in the output collection. As this is a no-operation plugin, the test could be further expanded to ensure that the parameters of the input message exactly match the parameters of the output message
    <br /><strong>046 - 067</strong> The business intent of the plugin is to insert exactly one entry containing details about the sequence and sequence position in a given Chatter Feed. The persistence of state outside the plugin is termed a side effect. The test verifies the correctness of the side effect by ensuring that process adds exactly one post to a given Chatter feed
</p>
