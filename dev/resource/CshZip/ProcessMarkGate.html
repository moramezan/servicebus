<h1>
    Mark and Gate processes
</h1>

<p>
    A related collection of messages may proceed down different execution paths. A need may still
    arise for a  process to act on these related messages in a single transaction context (even
    though one (or more) of these messages may have proceeded down different paths). A pattern that
    handles the above scenario is commonly known as a <em>Saga</em>.
</p>

<p>
    A <code>Shipping</code> service is a typical example of a Saga. From the perspective of the ESB
    framework, consider a <code>Shipping</code> sequence that begins with a
    <code>Customer-Order</code> message.
</p>

<ul>
    <li>
        The <code>Shipping</code> sequence will typically reach out to two helper sequences: a
        <code>Bill-Customer</code> sequence and an <code>Accept-Order</code> sequence.
    </li>
    <li>
        These two (sub)sequences will asynchronously report back to the <code>Shipping</code>
        sequence via a <code>Customer-Billed</code> message and an <code>Order-Accepted</code>
        message.
    </li>
    <li>
        Unfortunately, the arrival order of these two asynchronous messages is unknown until
        runtime.
    </li>
    <li>
        For this reason, the <code>Shipping</code> sequence will need to <em>hold up</em> and not
        release the <code>Customer-Order</code> message until until BOTH the
        <code>Customer-Billed</code> and <code>Order-Accepted</code> messages have returned to the
        <code>Shipping</code> sequence.
    </li>
</ul>

<p>
    Using the above example, the ESB framework would:
</p>

<ul>
    <li>
        make use of a <em>Mark</em> process immediately prior to a custom <em>Dispatcher</em>
        process
    </li>
    <li>
        <p>
            the custom written <code>Dispatcher</code> process would fan out the
            <code>Customer-Order</code> message as:
        </p>
        <ul>
            <li>
                a <code>Customer-Billed</code> message to the <code>Bill-Customer</code> sequence,
                and
            </li>
            <li>
                a <code>Order-Accepted</code> message to the <code>Accept-Order</code> sequence.
            </li>
        </ul>
    </li>
    <li>
        A <em>Gate</em> process would be placed after the <em>Dispatcher</em> process to
        buffer the returned <code>Customer-Billed</code> and <code>Order-Accepted</code> messages.
    </li>
    <li>
        This <em>Gate</em> process would release the <code>Customer-Order</code> message after
        receiving both the <code>Customer-Billed</code> and <code>Order-Accepted</code> messages.
    </li>
</ul>

<p>
    In summary, the ESB framework uses a <em>Mark</em> process and a <em>Gate</em> process in tandem
    to implement a Saga.
</p>

<ul>
    <li>
        First, the <em>Mark</em> process annotates a message suggesting it (and the messages it
        subsequently spawns) will be used in a saga.
    </li>
    <li>
        Later, a downstream <em>Gate</em> process buffers and releases logically related messages.
    </li>
</ul>

<h2>
    Usage
</h2>

<ul>
    <li>
        Insert a <em>Mark</em> process immediately before a fan-out process in a Sequence.
    </li>
    <li>
        Insert a <em>Gate</em> process at some point after the fan-out process
    </li>
</ul>

<!--
 ! TODO merge these?
 ! <h2>About the Gate and Mark Processes</h2>
 ! <p>A common requirement is the ability to process a related collection of asynchronous messages in a single synchronous transaction. The pattern for implementing this requirement is commonly known as a "Saga".</p>
 ! <p>A Mark process and a Gate process work together in the ESB framework to implement a Saga. First, the Mark process annotates a message suggesting it (and the messages it subsequently spawns) will be used in a saga. Later, a downstream Gate process buffers and releases logically related messages.</p>
 ! <p>To build a Saga:</p>
 ! <ul>
 !     <li>Place a Mark process immediately before your custom  message spawning process. <br/> (for example, place a Mark process immediately before  a Statement Line splitter process)</li>
 !     <li>All output messages generated by the spawning process will be subject to the Saga.</li>
 !     <li>At an appropriate point downstream in the sequence, insert a Gate process.</li>
 !     <li>Messages belonging to the Saga will be buffered  at the Gate process until the last related message is received.</li>
 !     <li>Upon receipt of the last related message, the Gate process will release a  single saga message containing the saga Id that references all messages in the Saga.</li>
 !     <li>Any custom process placed after the Gate process can use this saga Id to process all messages in the saga in a single synchronous transaction.</li>
 ! </ul>
 !-->